XPath
-----

XPath(XML Path) is an expression that is used to find the element or say node in the XML document (DOM).
In Selenium it is commonly used to find the web elements.

Syntax: //tagname[@attribute = 'value']

XPath expressions:
-----------------
1. //           Selects nodes in the document from the current node that match the selection no matter where they are(Direcltyjumps to that element).
2. /            Selects the root node
3. tagname      tagname of the element (current node in the DOM)
4. @            select the attribute
5. attribute    attribute name of the node or element
6. value        value of the attribute

Types of XPath
--------------
1. Absolute XPath
2. Relative XPath

1. Absolute XPath (Full XPath):
------------------------------
--> Absolute XPath uses the root element of the HTML/XML code and followed by all the elements which are necessary to reach the desired element.
--> It starts with the forward slash '/' 
--> Example: /html/body/div[6]/header/div[2]/div[1]/a/img
--> It starts from the root element and goes until the required element is found in the DOM.

2. Relative XPath (Partial XPath):
---------------------------------
--> XPath begins with the double forward slash '//' which means it can search the element anywhere in the Webpage.
--> It is preferrable because as they are not complete path from Root node.
--> Example: //input[@placeholder='search']

How to find an XPath?
---------------------
1. Go the web page and inspect the page 
2. Highlight the element and in the DOM right click on it
3. Then select copy either "full XPath" or "abs XPath"
4. You can use SelectorsHub also to find the XPaths.

Difference between Absolute XPath and Relative XPath?
-----------------------------------------------------
1. Absolute XPath starts with "/" (represents root node) while Relative XPath starts with "//"
2. Absolute XPath do not use attributes but Relative XPath works with attributes
3. Absolute XPath traverse through each node or element from the root node till it finds the element
   Relative XPath direclty jumps and find the element using the attribute

Always Relative XPath is preferable why?
----------------------------------------
--> Assume that the developer always changes the elements in the webpage, maybe position in the page
    and what happens to your Absolute XPath
    lets say this is the abs XPath /html/body/div[6]/header/div[2]/div[1]/a/img
    later developer changed the location or hierarchy of the tag "img"
    then your previous XPath does not work because developer changed the location or hierarchy in the DOM
    Hence it is not preferable
--> Relative XPath works with attributes, even though developer changed the location or hierarchy o the element
    continously it works because it depends on attributes. it remains unchanged


Relative XPath:
--------------
1. Automatically find XPath from using devtools, SelectorsHub and etc.
2. Manually write the relative xpath

Syntax: //tagname[@attribute] where attribute --> property='value'
                        (or)
        //*[@attribute='value'] --> if you do not know the tagname then use *
Example: //input[@placeholder='search'] or //*[@placeholder='search'] both will work


XPath with single attribute
---------------------------
--> An XPath with a single attribute is a powerful expression used to locate specific elements within
    an XML or HTML document (DOM) by referencing one of the element's attributes and its value. 
Example: driver.findElement(By.xpath("//input[@id='small-searchterms']")).sendKeys("Mac");


XPath with multiple attributes
------------------------------
--> XPath with multiple attributes is a method for precisely locating an element in an XML or HTML document 
    by combining two or more conditions on its attributes.
--> it is used when single attribute is not enough to identify the element in the xml or html document
Example: driver.findElement(By.xpath("//input[@id='small-searchterms'][@placeholder='Search store']")).sendKeys("MacBook");
Syntax: //tagname[@attribute1='value1'][@attribute2='value2"]


xpath with and operator
-----------------------
--> "and" operator is used when all attributed and ANDed together, all conditions are satisfied
Syntax: //tagname[attribute='value' and attribute='value']
--> Example: driver.findElement(By.xpath("//input[@id='small-searchterms' and @placeholder='Search store']")).sendKeys("windows");
--> There is no difference between "and" operator and xpath with multiple attributes both are same.


xpath with or operator
----------------------
--> "or" operator is used when at least one condition is true
--> at least one attribute is matched then it finds the element
Syntax: //tagname[attribute='value' or attribute='value']
--> Example: driver.findElement(By.xpath("//input[@id='small-searchterms' or @placeholder='Sch store']")).sendKeys("windows");


we can write the relative xpath without attributes also by using inner text
---------------------------------------------------------------------------
--> Inner text is the text in which it lies in between opening tag and closing tag.
--> Example: <h1>Hello</h1> here "Hello" is inner text

Syntax: //tagname[text()='inner text'], it goes to the tag and "text()" method return the inner text then it validates
--> Example: driver.findElement(By.xpath("//a[text()='Apple MacBook Pro']")).click();


NOTE:
    text() and . both are same (instead of writing text() we can put . also)
    1. All link text can be inner text.
    2. All inner text cannot be link text.

    1. <a href="https://befkj.com">click me</a>
    2. <h1>Hello</h1>

    Observe the above two html elements,
    first element is both inner text and link text
    second element is only inner text but it can't link text


contains()
---------
--> contains() method is used to find an element by using sub string of the string, i.e attribute value
--> You don't need to give the full value of the attribute, just a part of it.
Syntax: //tagname[contains(@attribute,'value')]
--> Example: //input[contains(@id='small')], if id value contains 'searchterms' then it will identify the element
Here id = small-searchterms

Example:
--------
Let's say tagname is 'input' and one of the attribute is placeholder and its value is 'Search store'
In different ways you can write xpath using contains() method. i.e, different sub strings.
--> driver.findElement(By.xpath("//input[contains(@placeholder,'store')]")).sendKeys("Mac");
--> driver.findElement(By.xpath("//input[contains(@placeholder,'ore')]")).sendKeys("Mac");
--> driver.findElement(By.xpath("//input[contains(@placeholder,'Search store')]")).sendKeys("Mac");
--> driver.findElement(By.xpath("//input[contains(@placeholder,'st')]")).sendKeys("Mac");

starts-with()
-------------
--> starts-with() method is used to find an element in the xml/html document by using the starting portion value of the attribute
--> You have to specify the starting value of the attribute
--> For example id = 'search store' then we can search this element by starting value of the attribute like 'sea', 'search', 'search st' in all possible ways
Syntax: //tagname[starts-with(@attribute,'value')]
Example: driver.findElement(By.xpath("//input[starts-with(@placeholder, 'Sea')]")).sendKeys("Linux");
        driver.findElement(By.xpath("//input[starts-with(@placeholder, 'Search s')]")).sendKeys("Linux");

Difference between contains() and starts-with():
--> contains() method can check the string in anywhere
--> starts-with() method can check the string from begining of the string

These two methods are very important in case of dynamic attributes
-------------------------------------------------------------------
1. Handling dynamic attributes --> attribute values are always changed.
--> lets say there is an attribute called name and its value is keep changing like,

name = abc001, abc002, abc003, abc004
to write xpath for these dynamic attribute is possible by using contains() or starts-with() methods
Example: //*[contains(@name,'abc')] or //*[contains(@name,'00')] or //*[contains(@name,'ab')]
        //*[starts-with(@name,'abc')] or //*[starts-with(@name,'ab')]


Chained XPath
-------------
--> If you don't have any attributes of a particular element then you go to its parent element until you find an attribute in the parent element.

Observe the following html code
<div id="logo">
    <a href="https://abc.com/"> 
        <img src="https://xyz.com"/>
    </a>
</div>

--> You want identify the img element but it does not have any attributes or inner text.
--> Then you go its parent element and see is there any attributes are there no. keep going to its parent element(grand parent of img)
--> There is an attribute called logo from that element you have write the xpath

Syntax:
-------
//parent-tag[@parent-attribute = 'value']/path to reach the required element

In the above case the xpath will be: //div[@id='logo']/a/img
--> This is combination of relative and absolute xpath
--> //div[@id='logo'] this is relative xpath
--> /a/img this is absolute xpath
--> So chained xpath is combination of relative and absolute xpath.


